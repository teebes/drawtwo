"""
Trait processing system for game cards.

This module processes events and triggers trait effects like Charge, Battlecry,
and Deathrattle. It follows an event-driven paradigm where traits respond to
game events rather than being called directly by effect handlers.
"""

import logging
from typing import Callable
from pydantic import TypeAdapter, ValidationError

from apps.gameplay.schemas.game import GameState, CardInPlay
from apps.builder.schemas import Trait, Action, DamageAction, DrawAction
from apps.gameplay.schemas.effects import DrawEffect, DamageEffect
from apps.gameplay.schemas.engine import Result, Success
from apps.gameplay.schemas.events import Event, PlayEvent, DamageEvent
from apps.gameplay.services import GameService

logger = logging.getLogger(__name__)


# Maps event types to trait types that should trigger on those events
EVENT_TRAIT_TRIGGERS = {
    'event_play': ["charge", "battlecry"],
    'event_damage': ["deathrattle"],  # When a card takes lethal damage
    # Add more mappings as needed:
    # 'event_end_turn': ["end_of_turn_effect"],
    # 'event_draw': ["when_drawn"],
}


def apply(state: GameState, event: Event) -> Result:
    """
    Main entry point for trait processing.

    Processes an event and triggers any relevant traits on cards in play.
    Returns child effects that should be enqueued.

    Args:
        state: Current game state
        event: Event that just occurred

    Returns:
        Result containing any child effects generated by trait triggers
    """
    child_effects = []
    events = []

    # Get list of traits that should trigger for this event type
    triggered_traits = EVENT_TRAIT_TRIGGERS.get(event.type, [])
    if not triggered_traits:
        return Success(new_state=state, events=[], child_effects=[])

    # For events that reference a specific card, check that card's traits
    if getattr(event, 'source_type', None) in ['card', 'creature']:
        card = state.cards.get(event.source_id)
        if card:
            for trait in card.traits:
                if trait.type in triggered_traits:
                    handler = TRAIT_HANDLERS.get(trait.type)
                    if handler:
                        result = handler(state, event, card, trait)
                        events.extend(result.events)
                        child_effects.extend(result.child_effects)

    # For board-wide effects, check all cards on the board
    # (e.g., "whenever ANY creature is played" effects)
    # This can be extended later for triggered abilities

    return Success(
        new_state=state,
        events=events,
        child_effects=child_effects
    )


# ============================================================================
# Individual Trait Handlers
# ============================================================================

def handle_charge_trait(
    state: GameState,
    event: Event,
    card: CardInPlay,
    trait: Trait
) -> Result:
    """
    Charge: Can attack immediately when played.

    Triggers on: PlayEvent
    Effect: Sets the card's exhausted state to False
    """
    card.exhausted = False
    return Success(new_state=state, events=[], child_effects=[])


def handle_battlecry_trait(
    state: GameState,
    event: Event,
    card: CardInPlay,
    trait: Trait
) -> Result:
    """
    Battlecry: Effect triggers when card is played from hand.

    Triggers on: PlayEvent
    Effect: Executes the trait's card actions
    """
    child_effects = []

    for card_action in trait.actions:
        try:
            card_action = TypeAdapter(Action).validate_python(card_action)
        except ValidationError:
            logger.warning(f"Invalid card action: {card_action}")
            continue

        effect = GameService.compile_action(
            state=state,
            event=event,
            action=card_action,
        )
        child_effects.append(effect)

    return Success(
        new_state=state,
        events=[],
        child_effects=child_effects
    )


def handle_deathrattle_trait(
    state: GameState,
    event: Event,
    card: CardInPlay,
    trait: Trait
) -> Result:
    """
    Deathrattle: Effect triggers when card is destroyed.

    Triggers on: DamageEvent (when card health <= 0)
    Effect: Executes the trait's card actions
    """
    # Only trigger if the card actually died
    if isinstance(event, DamageEvent) and card.health <= 0:
        child_effects = []

        for card_action in trait.actions:
            result = GameService.compile_action(state, card_action)
            child_effects.extend(result.child_effects)

        return Success(
            new_state=state,
            events=[],
            child_effects=child_effects
        )

    return Success(new_state=state, events=[], child_effects=[])


# Registry mapping trait type codes to their handler functions
TRAIT_HANDLERS: dict[str, Callable[[GameState, Event, CardInPlay, Trait], Result]] = {
    "charge": handle_charge_trait,
    "battlecry": handle_battlecry_trait,
    "deathrattle": handle_deathrattle_trait,
}