"""
Trait processing system for game cards.

This module processes events and triggers trait effects like Charge, Battlecry,
and Deathrattle. It follows an event-driven paradigm where traits respond to
game events rather than being called directly by effect handlers.
"""

import logging
from typing import Callable
from pydantic import TypeAdapter, ValidationError


from apps.builder.schemas import Trait, Action, DamageAction, DrawAction
from apps.gameplay.schemas.effects import DrawEffect, DamageEffect
from apps.gameplay.schemas.engine import Result, Success, Rejected
from apps.gameplay.schemas.events import (
    Event,
    CreatureDeathEvent,
    PlayEvent,
)
from apps.gameplay.schemas.game import GameState, CardInPlay, Creature
from apps.gameplay.services import GameService

logger = logging.getLogger(__name__)


# Maps event types to trait types that should trigger on those events
EVENT_TRAIT_TRIGGERS = {
    'event_play': ["charge", "battlecry"],
    'event_creature_death': ["deathrattle"],
}


def apply(state: GameState, event: Event) -> Result:
    """
    Main entry point for trait processing.

    Processes an event and triggers any relevant traits on cards in play.
    Returns child effects that should be enqueued.

    Args:
        state: Current game state
        event: Event that just occurred

    Returns:
        Result containing any child effects generated by trait triggers
    """
    child_effects = []
    events = []

    # Get list of traits that should trigger for this event type
    triggered_traits = EVENT_TRAIT_TRIGGERS.get(event.type, [])
    if not triggered_traits:
        return Success(new_state=state, events=[], child_effects=[])

    # The entity which may have a trait (creature, card or hero)
    entity = None
    if isinstance(event, CreatureDeathEvent):
        entity = event.creature
    elif getattr(event, 'source_type', None) in ['card', 'creature']:
        entity = state.cards.get(event.source_id)
    elif getattr(event, 'source_type', None) == 'hero':
        entity = state.heroes.get(event.source_id)
    else:
        raise ValueError("Unable to determine entity for event: %s" % event)

    if entity:
        for trait in entity.traits:
            if trait.type in triggered_traits:
                handler = TRAIT_HANDLERS.get(trait.type)
                if handler:
                    result = handler(state, event, entity, trait)
                    events.extend(result.events)
                    child_effects.extend(result.child_effects)
    else:
        raise ValueError(f"Invalid entity: {entity}")

    # For board-wide effects, check all cards on the board
    # (e.g., "whenever ANY creature is played" effects)
    # This can be extended later for triggered abilities

    return Success(
        new_state=state,
        events=events,
        child_effects=child_effects
    )


# ============================================================================
# Individual Trait Handlers
# ============================================================================

def handle_charge_trait(
    state: GameState,
    event: PlayEvent,
    card: CardInPlay,
    trait: Trait
) -> Result:
    """
    Charge: Can attack immediately when played.

    Triggers on: PlayEvent
    Effect: Sets the card's exhausted state to False
    """
    creature = state.creatures.get(event.creature_id)
    if not creature:
        return Rejected(reason=f"Creature {event.creature_id} does not exist")
    creature.exhausted = False
    return Success(new_state=state, events=[], child_effects=[])


def handle_battlecry_trait(
    state: GameState,
    event: PlayEvent,
    card: CardInPlay,
    trait: Trait
) -> Result:
    """
    Battlecry: Effect triggers when card is played from hand.

    Triggers on: PlayEvent
    Effect: Executes the trait's card actions
    """
    child_effects = []

    for card_action in trait.actions:
        try:
            card_action = TypeAdapter(Action).validate_python(card_action)
        except ValidationError:
            logger.warning(f"Invalid card action: {card_action}")
            continue

        effects = GameService.compile_action(
            state=state,
            event=event,
            action=card_action,
        )
        child_effects.extend(effects)

    return Success(
        new_state=state,
        events=[],
        child_effects=child_effects
    )


def handle_deathrattle_trait(
    state: GameState,
    event: Event,
    creature: Creature,
    trait: Trait
) -> Result:
    """
    Deathrattle: Effect triggers when card is destroyed.

    Triggers on: DamageEvent (when card health <= 0)
    Effect: Executes the trait's card actions
    """
    # Only trigger if the card actually died
    child_effects = []

    for card_action in trait.actions:
        effects = GameService.compile_action(
            state=state,
            event=event,
            action=card_action)
        child_effects.extend(effects)

    return Success(
        new_state=state,
        events=[],
        child_effects=child_effects
    )


# Registry mapping trait type codes to their handler functions
TRAIT_HANDLERS: dict[str, Callable[[GameState, Event, CardInPlay, Trait], Result]] = {
    "charge": handle_charge_trait,
    "battlecry": handle_battlecry_trait,
    "deathrattle": handle_deathrattle_trait,
}